<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reset 2FA QR Code - Navikko Admin</title>
    <link rel="stylesheet" href="/fresh-2fa-setup.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”„ Reset 2FA QR Code - Navikko Admin</h1>
            <p>Generate a fresh TOTP secret for resetting your 2FA setup</p>
        </div>

        <div class="warning">
            <h3>âš ï¸ Important</h3>
            <p>This will generate a completely new 2FA secret. You'll need to remove the old Navikko entry from Google Authenticator and add this new one.</p>
        </div>

        <button onclick="generateFresh2FA()">ğŸ”„ Generate Fresh 2FA Secret</button>

        <div id="setupSection" class="setup-section hidden">
            <div class="secret-section">
                <h3>ğŸ“± New TOTP Secret</h3>
                <div class="secret-code" id="secretDisplay"></div>
                <p><strong>Account:</strong> <span id="accountEmail">wasando.tsuyukusa@gmail.com</span></p>
                <p><strong>Issuer:</strong> Navikko</p>
            </div>

            <div class="qr-section">
                <h3>ğŸ“± QR Code for Google Authenticator</h3>
                <div id="qrcode">
                    <img id="qrImg" alt="2FA QR" style="width:220px;height:220px;display:none;" />
                </div>
                <p><a id="qrLink" href="#" target="_blank" rel="noopener" style="display:none;">Open QR in a new tab</a></p>
                <p>Scan this QR code with Google Authenticator</p>
            </div>

            <div class="instructions">
                <h3>ğŸ“‹ Reset Instructions</h3>
                <ol>
                    <li><strong>Remove old entry:</strong> Delete any existing "Navikko" entry from Google Authenticator</li>
                    <li><strong>Add new entry:</strong> Scan the QR code above or manually enter the secret</li>
                    <li><strong>Verify setup:</strong> Check that the current code matches below</li>
                    <li><strong>Update database:</strong> Copy the SQL command to update the database</li>
                    <li><strong>Test login:</strong> Try logging in with the new code</li>
                </ol>
            </div>

            <div class="qr-section">
                <h3>ğŸ• Current TOTP Code</h3>
                <div class="current-code" id="currentCode">------</div>
                <div class="countdown" id="countdown">--</div>
                <p>This should match your Google Authenticator</p>
            </div>

            <div class="success">
                <h3>ğŸ’¾ Database Update SQL</h3>
                <p>Run this SQL command to update the database with the new secret:</p>
                <div class="secret-code" id="sqlCommand"></div>
                <button onclick="copySQLCommand()">ğŸ“‹ Copy SQL Command</button>
            </div>

            <div class="debug-info">
                <h4>ğŸ” Debug Information</h4>
                <div id="debugInfo"></div>
            </div>
        </div>
    </div>

    <script>
        // Helper to read optional email from URL (?email=...)
        function getParam(name) {
            const url = new URL(window.location.href);
            return url.searchParams.get(name);
        }

        // TOTP Service with corrected endianness handling
        class TOTPService {
            constructor(config = {}) {
                this.config = {
                    secret: config.secret || this.generateSecret(),
                    digits: config.digits || 6,
                    period: config.period || 30,
                    algorithm: config.algorithm || 'SHA1'
                };
            }

            generateSecret() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
                let secret = '';
                for (let i = 0; i < 32; i++) {
                    secret += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return secret;
            }

            base32ToBytes(base32) {
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
                const bytes = [];
                let bits = 0;
                let value = 0;

                for (let i = 0; i < base32.length; i++) {
                    const char = base32[i].toUpperCase();
                    const index = alphabet.indexOf(char);
                    if (index === -1) continue;

                    value = (value << 5) | index;
                    bits += 5;

                    if (bits >= 8) {
                        bytes.push((value >>> (bits - 8)) & 0xFF);
                        bits -= 8;
                    }
                }

                return new Uint8Array(bytes);
            }

            async generateCode() {
                const counter = Math.floor(Date.now() / 1000 / this.config.period);
                return this.generateCodeForCounter(counter);
            }

            async generateCodeForCounter(counter) {
                // Convert counter to 8-byte buffer (big-endian)
                const buffer = new ArrayBuffer(8);
                const view = new DataView(buffer);
                view.setBigUint64(0, BigInt(counter), false); // false = big-endian

                // Convert secret to bytes
                const secretBytes = this.base32ToBytes(this.config.secret);

                // Generate HMAC-SHA1
                const key = await crypto.subtle.importKey(
                    'raw',
                    secretBytes,
                    { name: 'HMAC', hash: 'SHA-1' },
                    false,
                    ['sign']
                );

                const signature = await crypto.subtle.sign('HMAC', key, buffer);
                const hash = new Uint8Array(signature);

                // Generate 6-digit code using RFC 6238 standard with corrected endianness
                const offset = hash[hash.length - 1] & 0xf;
                
                if (offset + 3 >= hash.length) {
                    throw new Error('Invalid hash length for TOTP generation');
                }
                
                // FIXED: Use DataView for consistent big-endian byte order
                const codeBuffer = new ArrayBuffer(4);
                const codeView = new DataView(codeBuffer);
                codeView.setUint8(0, hash[offset]);
                codeView.setUint8(1, hash[offset + 1]);
                codeView.setUint8(2, hash[offset + 2]);
                codeView.setUint8(3, hash[offset + 3]);
                const code = codeView.getUint32(0, false); // false = big-endian

                // Apply RFC 6238 mask to clear the high bit
                const maskedCode = code & 0x7fffffff;

                const modulo = Math.pow(10, this.config.digits);
                return (maskedCode % modulo).toString().padStart(this.config.digits, '0');
            }

            generateQRCodeURL(accountName, issuer = 'Navikko') {
                const secret = this.config.secret;
                const url = `otpauth://totp/${encodeURIComponent(issuer)}:${encodeURIComponent(accountName)}?secret=${secret}&issuer=${encodeURIComponent(issuer)}&algorithm=${this.config.algorithm}&digits=${this.config.digits}&period=${this.config.period}`;
                return url;
            }

            getSecret() {
                return this.config.secret;
            }

            getRemainingTime() {
                const now = Math.floor(Date.now() / 1000);
                const period = this.config.period;
                return period - (now % period);
            }

            getCurrentCounter() {
                return Math.floor(Date.now() / 1000 / this.config.period);
            }
        }

        let totpService;
        let updateInterval;

        async function generateFresh2FA() {
            // Generate new TOTP service with fresh secret
            totpService = new TOTPService();
            
            const secret = totpService.getSecret();
            const adminEmail = getParam('email') || 'wasando.tsuyukusa@gmail.com';
            document.getElementById('accountEmail').textContent = adminEmail;
            const qrUrl = totpService.generateQRCodeURL(adminEmail, 'Navikko');
            
            // Display secret
            document.getElementById('secretDisplay').textContent = secret;
            
            // Show QR via stable image endpoint
            const qrData = 'https://api.qrserver.com/v1/create-qr-code/?size=220x220&data=' + encodeURIComponent(qrUrl);
            const img = document.getElementById('qrImg');
            img.src = qrData;
            img.style.display = 'block';
            const link = document.getElementById('qrLink');
            link.href = qrData;
            link.style.display = 'inline';
            
            // Generate SQL command with actual values
            const sqlCommand = `UPDATE admin_access a\nSET two_factor_secret = '${secret}',\n    two_factor_enabled = true\nFROM users u\nWHERE a.user_id = u.id\n  AND u.email = '${adminEmail}';`;
            document.getElementById('sqlCommand').textContent = sqlCommand;
            // Note: Replace [NEW_SECRET] with the actual secret displayed above
            
            // Show setup section
            document.getElementById('setupSection').classList.remove('hidden');
            
            // Start updating current code
            updateCurrentCode();
            updateInterval = setInterval(updateCurrentCode, 1000);
            
            console.log('âœ… Fresh 2FA setup generated');
            console.log('Secret:', secret);
            console.log('QR URL:', qrUrl);
        }

        async function updateCurrentCode() {
            if (!totpService) return;
            
            try {
                const code = await totpService.generateCode();
                const remaining = totpService.getRemainingTime();
                const counter = totpService.getCurrentCounter();
                
                document.getElementById('currentCode').textContent = code;
                document.getElementById('countdown').textContent = `Refreshes in ${remaining} seconds`;
                
                // Update debug info
                const debugInfo = `
Current Time: ${new Date().toISOString()}
Unix Timestamp: ${Math.floor(Date.now() / 1000)}
Counter: ${counter}
Current Code: ${code}
Time Remaining: ${remaining}s
Secret: ${totpService.getSecret()}
                `.trim();
                
                document.getElementById('debugInfo').textContent = debugInfo;
                
            } catch (error) {
                console.error('Error generating code:', error);
                document.getElementById('currentCode').textContent = 'ERROR';
            }
        }

        function copySQLCommand() {
            const sqlCommand = document.getElementById('sqlCommand').textContent;
            navigator.clipboard.writeText(sqlCommand).then(() => {
                alert('SQL command copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback: select the text
                const range = document.createRange();
                range.selectNode(document.getElementById('sqlCommand'));
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(range);
            });
        }

        // Cleanup interval on page unload
        window.addEventListener('beforeunload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
        });
    </script>
</body>
</html>